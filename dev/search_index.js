var documenterSearchIndex = {"docs":
[{"location":"build_tips/#Tips-for-Building-Packages-1","page":"Building Packages","title":"Tips for Building Packages","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"BinaryBuilder provides a convenient environment to enable cross-platform building. But, many libraries have complicated build scripts that may need to be adapted to support all of the BinaryBuilder targets.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"If your build fails with some errors, look at the Build Troubleshooting page.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"If you have additional tips, please submit a PR with suggestions.","category":"page"},{"location":"build_tips/#Initiating-different-shell-commands-based-on-target-1","page":"Building Packages","title":"Initiating different shell commands based on target","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Sometimes, you need to adapt build scripts based on the target platform. This can be done within the shell script. Here is an example from staticfloat/OpenBLASBuilder:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"# Set BINARY=32 on i686 platforms and armv7l\nif [[ ${nbits} == 32 ]]; then\n    flags=\"${flags} BINARY=32\"\nfi","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Here are other examples of scripts with target-specific checks:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"XZ - Custom windows installation\nSundials - 32-bit check","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"It is also possible to run quite different scripts for each target by running different build scripts for different sets of targets. Here is an example where windows builds are separated from other targets:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Git","category":"page"},{"location":"build_tips/#Autoconfigure-builds-1","page":"Building Packages","title":"Autoconfigure builds","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Autoconfigure builds are generally quite straightforward. Here is a typical approach:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"./configure --prefix=$prefix --build=${MACHTYPE} --host=${target}\nmake -j${nproc}\nmake install","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Here are examples of autoconfigure build scripts:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Patchelf\nLibCURL","category":"page"},{"location":"build_tips/#CMake-builds-1","page":"Building Packages","title":"CMake builds","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"For CMake, the wizard will suggest a template for running CMake. Typically, this will look like:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"cmake -DCMAKE_INSTALL_PREFIX=${prefix} -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TARGET_TOOLCHAIN} -DCMAKE_BUILD_TYPE=Release","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"The toolchain file sets up several CMake environment variables for better cross-platform support, such as CMAKE_SYSROOT, CMAKE_C_COMPILER, etc...  Examples of builds that include CMake parts include:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"JpegTurbo\nSundials\nNeeds -DSUNDIALS_INDEX_TYPE=int32_t on 32-bit targets (Sundials-specific way to specify integer size)\nNeeds to copy *.dll files from destdir/lib to destdir/bin for windows; this also removes symlinks by using cp -L\nNeeds -DCMAKE_FIND_ROOT_PATH=\"$WORKSPACE/destdir\", so CMake's find_library can find libraries from KLU","category":"page"},{"location":"build_tips/#Meson-builds-1","page":"Building Packages","title":"Meson builds","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"BinaryBuilder supports also building with Meson.  Since this is going to be a cross-compilation, you have to specify a Meson cross file:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"meson --cross-file=\"${MESON_TARGET_TOOLCHAIN}\"","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"After configuring the project with meson, you can then build and install it with","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"ninja -j${nproc}\nninja install","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"The wizard automatically suggests using Meson if the meson.build file is present.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Examples of builds performed with Meson include:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"gdk-pixbuf\nHere meson uses platform-dependent options\nlibepoxy\nThis script modifies c_args in the Meson cross file in order to add an include directory\nxkbcommon","category":"page"},{"location":"build_tips/#Builds-with-binary-dependencies-1","page":"Building Packages","title":"Builds with binary dependencies","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"A build script can depend on binaries generated by another builder. A builder specifies dependencies in the form of previously-built JLL packages:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"# Dependencies of Xorg_xkbcomp\ndependencies = [\n    Dependency(\"Xorg_libxkbfile_jll\"),\n    BuildDependency(\"Xorg_util_macros_jll)\",\n]","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Dependency specify a JLL package that is necessary to build and load the current builder;\nBuildDependency is a JLL package necessary only to build the current package, but not to load it.  This dependency will not be added to the list of the dependencies of the generated JLL package.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"In the wizard, dependencies can be specified with the prompt: Do you require any (binary) dependencies?  [y/N].","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Examples of builders that depend on other binaries include:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"ImageMagick depends on Zlib, libpng, JpegTurbo and Libtiff.","category":"page"},{"location":"build_tips/#Building-a-platform-independent-package-1","page":"Building Packages","title":"Building a platform-independent package","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"BinaryBuilder.jl is particularly useful to build packages involving shared libraries and binary executables.  There is little benefit in using this package to build a package that would be platform-independent, for example to install a dataset to be used in a Julia package on the user's machine.  For this purpose a simple Artifacts.toml file generated with create_artifact would do exactly the same job.  Nevertheless, there are cases where a platform-independent JLL package would still be useful, for example to build a package containing only header files that will be used as dependency of other packages.  To build a platform-independent package you can use the special platform AnyPlatform:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"platforms = [AnyPlatform()]","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Within the build environment, an AnyPlatform looks like x86_64-linux-musl, but this shouldn't affect your build in any way.  Note that when building a package for AnyPlatform you can only have products of type FileProduct, as all other types are platform-dependent.  The JLL package generated for an AnyPlatform is platform-independent and can thus be installed on any machine.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Example of builders using AnyPlatform:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"OpenCL_Headers;\nSPIRV_Headers.","category":"page"},{"location":"build_tips/#Editing-files-in-the-wizard-1","page":"Building Packages","title":"Editing files in the wizard","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"In the wizard, the vim editor is available for editing files. But, it doesn't leave any record in the build script. One generally needs to provide patch files or use something like sed. If a file needs patching, we suggest using git to add the entire worktree to a new repo, make the changes you need, then use git diff -p to output a patch that can be included alongside your build recipe.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"You can include local files like patches very easily by placing them within a bundled/patches nested directory, and then providing \"./bundled\" as one of the sources for your build.  See, for example, OpenBLAS.","category":"page"},{"location":"build_tips/#Automatic-environment-variables-1","page":"Building Packages","title":"Automatic environment variables","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"The following environment variables are automatically set in the build environment and should be used to build the project.  Occasionally, you may need to tweak them (e.g., when Using GCC on macOS and FreeBSD).","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"CC: the C cross compiler\nCXX: the C++ cross compiler\nFC: the Fortran cross compiler\nOBJC: the Objective-C cross compiler","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"The above variables point to utilities for the target environment.  To reference the utilities for the host environment either prepend HOST or append _HOST.  For example, HOSTCC and CC_HOST point to the native C compiler.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"These are other environment variables that you may occasionally need to set during a build","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"CFLAGS: options for the C compiler\nCXXFLAGS: options for the C++ compiler\nCPPFLAGS: options for the C pre-processor\nLDFLAGS: options for the linker\nPKG_CONFIG_PATH: a colon-separated list of directories to search for .pc files\nPKG_CONFIG_SYSROOT_DIR: modifies -I and -L to use the directories located in target sysroot","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"The following variables are useful to control the build script over different target systems, but are not intended to be modified by the users:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"prefix: the path to the top-directory of where all the products should be installed.  This will be the top-directory of the generated tarball\nlibdir: the path to the directory where the shared libraries should be installed.  This is ${prefix}/bin when building for Windows, ${prefix}/lib for all other platforms\nbindir: the path to the directory where the executables should be installed.  This is equivalent to ${prefix}/bin\nincludedir: the path to the directory where the header files should be installed.  This is equivalent to ${prefix}/include\ntarget: the target platform\nbb_full_target: the full target platform, containing things like libstdc++ string ABI platform tags, and libgfortran version\nnproc: the number of processors of the host machine, useful for parallel building (e.g., make -j${nproc})\nnbits: number of bits of the target architecture (usually it is either 32 or 64)\nproc_family: target processor family (e.g., \"intel\", \"power\", or \"arm\")\ndlext: extension of the shared library on the target system.  It is \"dll\" for Windows, \"dylib\" for macOS, and \"so\" for the other Unix systems\nexeext: extension of the executable on the target system, including the dot if present.  It is \".exe\" for Windows and the empty string \"\" for all the other target platforms\nSRC_NAME: name of the project being built","category":"page"},{"location":"build_tips/#Using-GCC-on-macOS-and-FreeBSD-1","page":"Building Packages","title":"Using GCC on macOS and FreeBSD","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"For these target systems Clang is the default compiler, however some programs may not be compatible with Clang.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"For programs built with CMake (see the CMake build section) you can use the GCC toolchain file that is in ${CMAKE_TARGET_TOOLCHAIN%.*}_gcc.cmake.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"If the project that you want to build uses the GNU Build System (also knows as the Autotools), there isn't an automatic switch to use GCC, but you have to set the appropriate variables.  For example, this setting can be used to build most C/C++ programs with GCC for FreeBSD and macOS:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"if [[ \"${target}\" == *-freebsd* ]] || [[ \"${target}\" == *-apple-* ]]; then\n    CC=gcc\n    CXX=g++\nfi","category":"page"},{"location":"build_tips/#Installing-the-license-file-1","page":"Building Packages","title":"Installing the license file","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Generated tarballs should come with the license of the library that you want to install.  If at the end of a successful build there is only one directory inside ${WORKSPACE}/srcdir, BinaryBuilder will look into it for files with typical names for license (like LICENSE, COPYRIGHT, etc... with some combinations of extensions) and automatically install them to ${prefix}/share/licenses/${SRC_NAME}/.  If in the final tarball there are no files in this directory a warning will be issued, to remind you to provide a license file.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"If the license file is not automatically installed (for example because there is more than one directory in ${WORKSPACE}/srcdir or because the file name doesn't match the expected pattern) you have to manually install the file.  In the build script you can use the install_license command.  See the Utilities in the build environment section below.","category":"page"},{"location":"build_tips/#Utilities-in-the-build-environment-1","page":"Building Packages","title":"Utilities in the build environment","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"In addition to the standard Unix tools, in the build environment there are some extra commands provided by BinaryBuilder.  Here is a list of some of these commands:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"atomic_patch: utility to apply patches.  It is similar to the standard patch, but it fails gracefully when a patch cannot be applied:\natomic_patch -p1 /path/to/file.patch\nflagon: utility to translate some compiler-flags to the one required on the current platform.  For example, to build a shared library from a static archive:\ncc -o \"${libdir}/libfoo.${dlext}\" -Wl,$(flagon --whole-archive) libfoo.a -Wl,$(flagon --no-whole-archive) -lm\nThe currently supported flags are:\n--whole-archive;\n--no-whole-archive;\n--relative-rpath-link.\ninstall_license: utility to install a file to ${prefix}/share/licenses/${SRC_NAME}:\ninstall_license ${WORKSPACE}/srcdir/THIS_IS_THE_LICENSE.md\nupdate_configure_scripts: utility to update autoconfigure scripts.  Sometimes libraries come with out-of-date autoconfigure scripts (e.g., old configure.guess can't recognise aarch64 platforms of systems using Musl C library).  Just run\nupdate_configure_scripts\nto get a newer version.  With the --reconf flag, it also runs autoreconf -i -f afterwards:\nupdate_configure_scripts --reconf","category":"page"},{"location":"rootfs/#RootFS-1","page":"RootFS","title":"RootFS","text":"","category":"section"},{"location":"rootfs/#","page":"RootFS","title":"RootFS","text":"The execution environment that all BinaryBuilder.jl builds are executed within is referred to as the \"root filesystem\" or RootFS.  This RootFS is built using the builder scripts contained within the 0_Rootfs directory within Yggdrasil.  The rootfs image is based upon the alpine docker image, and is used to build compilers for every target platform we support.  The target platform compiler toolchains are stored within /opt/${triplet}, so the 64-bit Linux (using glibc as the backing libc) compilers would be found in /opt/x86_64-linux-gnu/bin.","category":"page"},{"location":"rootfs/#","page":"RootFS","title":"RootFS","text":"Each compiler \"shard\" is packaged separately, so that users do not have to download a multi-GB tarball just to build for a single platform.  There is an overall \"root\" shard, along with platform support shards, GCC shards, an LLVM shard, Rust shards, etc... These are all embedded within the bundled Artifacts.toml file, and BinaryBuilder.jl downloads them on-demand as necessary, making use of the new Pkg.Artifacts system within Julia 1.3+.","category":"page"},{"location":"rootfs/#","page":"RootFS","title":"RootFS","text":"Each shard is made available both as an unpacked directory tree, and as a .squashfs image.  .squashfs images take up significantly less disk space, however they unfortunately require root privileges on the host machine, and only work on Linux.  This will hopefully be fixed in a future Linux kernel release, but if you have sudo privileges, it is often desirable to use the .squashfs files to save network bandwidth and disk space.  See the Environment Variables for instructions on how to do that.","category":"page"},{"location":"rootfs/#","page":"RootFS","title":"RootFS","text":"When launching a process within the RootFS image, BinaryBuilder.jl sets up a set of environment variables to enable a target-specific compiler toolchain, among other niceties.  See the Build Tips doc page for more details on that, along with the src/Runner.jl file within this repository for the implementation.","category":"page"},{"location":"environment_variables/#Environment-Variables-1","page":"Environment Variables","title":"Environment Variables","text":"","category":"section"},{"location":"environment_variables/#","page":"Environment Variables","title":"Environment Variables","text":"BinaryBuilder.jl supports multiple environment variables to modify its behavior globally:","category":"page"},{"location":"environment_variables/#","page":"Environment Variables","title":"Environment Variables","text":"BINARYBUILDER_AUTOMATIC_APPLE: when set to true, this automatically agrees to the Apple macOS SDK license agreement, enabling the building of binary objects for macOS systems.\nBINARYBUILDER_USE_SQUASHFS: when set to true, this uses .squashfs images instead of tarballs to download cross-compiler shards.  This consumes significantly less space on-disk and boasts a modest reduction in download size as well, but requires sudo on the local machine to mount the .squashfs images.  This is the default when using the \"privileged\" runner.\nBINARYBUILDER_RUNNER: When set to a runner string, alters the execution engine that BinaryBuilder.jl will use to wrap the build process in a sandbox.  Valid values are one of \"userns\", \"privileged\" and \"docker\".  If not given, BinaryBuilder.jl will do its best to guess.\nBINARYBUILDER_ALLOW_ECRYPTFS: When set to true, this allows the mounting of rootfs/shard/workspace directories from within encrypted mounts.  This is disabled by default, as at the time of writing, this triggers kernel bugs.  To avoid these kernel bugs on a system where e.g. the home directory has been encrypted, set the BINARYBUILDER_ROOTFS_DIR and BINARYBUILDER_SHARDS_DIR environment variables to a path outside of the encrypted home directory.\nBINARYBUILDER_USE_CCACHE: When set to true, this causes a /root/.ccache volume to be mounted within the build environment, and for the CC, CXX and FC environment variables to have ccache prepended to them.  This can significantly accelerate rebuilds of the same package on the same host.  Note that ccache will, by default, store 5G of cached data.\nBINARYBUILDER_NPROC: Overrides the value of the environment variable ${nproc} set during a build, see Automatic environment variables.","category":"page"},{"location":"FAQ/#Frequently-Asked-Questions-1","page":"FAQ","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"FAQ/#I'm-having-trouble-compiling-project-name-here-1","page":"FAQ","title":"I'm having trouble compiling <project name here>","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"First, make sure that you can compile that project natively on whatever platform you're attempting to compile it on.  Once you are assured of that, search around the internet to see if anyone else has run into issues cross-compiling that project for that platform.  In particular, most smaller projects should be just fine, but larger projects (and especially anything that does any kind of bootstrapping) may need some extra smarts smacked into their build system to support cross-compiling.  Finally, if you're still stuck, try reaching out for help on the #binarybuilder channel in the JuliaLang slack.","category":"page"},{"location":"FAQ/#How-do-I-use-this-to-compile-my-Julia-code?-1","page":"FAQ","title":"How do I use this to compile my Julia code?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"This package does not compile Julia code; it compiles C/C++/Fortran dependencies.  Think about that time you wanted to use IJulia and you needed to download/install libnettle.  The purpose of this package is to make generated tarballs that can be downloaded/installed painlessly as possible.","category":"page"},{"location":"FAQ/#What-is-this-I-hear-about-the-macOS-SDK-license-agreement?-1","page":"FAQ","title":"What is this I hear about the macOS SDK license agreement?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Apple restricts distribution and usage of the macOS SDK, a necessary component to build software for macOS targets.  Please read the Apple and Xcode SDK agreement for more information on the restrictions and legal terms you agree to when using the SDK to build software for Apple operating systems.  As usual, you should not take legal advice from FAQs on the internet, but in an effort to distill that large document down a bit, it is a breach of the license agreement to use the SDK to compile macOS binaries on a machine that is itself not a macOS machine.  Although this toolkit is designed to primarily run on Linux machines, it would not be breaking the license agreement to run this toolkit within a virtualized environment on a macOS machine, whereas it would be breaking the license agreement to run this toolkit on, for example, an Amazon AWS machine running Linux.  The Docker runner implements the virtualization approach on macOS machines.  BinaryBuilder.jl, by default, will not automatically download or use the macOS SDK on non-apple host operating systems, unless the BINARYBUILDER_AUTOMATIC_APPLE environment variable is set to true.","category":"page"},{"location":"FAQ/#Are-there-other-environment-variables-I-can-use?-1","page":"FAQ","title":"Are there other environment variables I can use?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Yes, take a look.","category":"page"},{"location":"FAQ/#Hey,-this-is-cool,-can-I-use-this-for-my-non-Julia-related-project?-1","page":"FAQ","title":"Hey, this is cool, can I use this for my non-Julia related project?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Absolutely!  There's nothing Julia-specific about the binaries generated by the cross-compilers used by BinaryBuilder.jl.  Although the best interface for interacting with this software will always be the Julia interface defined within this package, you are free to use these software tools for other projects as well.  Note that the cross-compiler image is built through a multistage bootstrapping process, see this repository for more information.  Further note the macOS SDK license agreement tidbit above.","category":"page"},{"location":"FAQ/#What-platforms-are-supported?-1","page":"FAQ","title":"What platforms are supported?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"At the time of writing, we support Linux (x86_64, i686, armv7l, aarch64, ppc64le), Windows (x86_64, i686), macOS (x86_64) and FreeBSD (x86_64).","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"You can get the list of the supported platforms and their associated triplets by using the functions supported_platforms and triplet:","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"using BinaryBuilder\nfor p in supported_platforms()\n    println(\"Platform: $(p); triplet: $(triplet(p))\")\nend","category":"page"},{"location":"FAQ/#At-line-XXX,-ABORTED-(Operation-not-permitted)!-1","page":"FAQ","title":"At line XXX, ABORTED (Operation not permitted)!","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Some linux distributions have a bug in their overlayfs implementation that prevents us from mounting overlay filesystems within user namespaces.  See this Ubuntu kernel bug report for a description of the situation and how Ubuntu has patched it in their kernels.  To work around this, you can launch BinaryBuilder.jl in \"privileged container\" mode.  BinaryBuilder should auto-detect this situation, however if the autodetection is not working or you want to silence the warning, you can set the BINARYBUILDER_RUNNER environment variable to privileged.  Unfortunately, this involves running sudo every time you launch into a BinaryBuilder session, but on the other hand, this successfully works around the issue on distributions such as Arch linux.","category":"page"},{"location":"FAQ/#I-have-to-build-a-very-small-project-without-a-Makefile,-what-do-I-have-to-do?-1","page":"FAQ","title":"I have to build a very small project without a Makefile, what do I have to do?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"What BinaryBuilder needs is to find the relevant file (shared libraries, or executables, etc...) organised under the $prefix directory: libraries should go to ${libdir}, executables to ${bindir}.  You may need to create those directories.  You are free to choose whether to create a simple Makefile to build the project or to do everything within the build_tarballs.jl script. When the script completes, BinaryBuilder expects to find at least one artifact built for the expected architecture in either ${libdir} or ${bindir}. Remember also that you should use the standard environment variables like CC, CXX, CFLAGS, LDFLAGS as appropriate in order to cross compile.  See the list of variables in the Tips for Building Packages section.","category":"page"},{"location":"FAQ/#I-love-the-wizard,-but-now-I-want-to-break-free:-can-I-build-the-tarballs-without-it?-1","page":"FAQ","title":"I love the wizard, but now I want to break free: can I build the tarballs without it?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"The build_tarballs.jl script can be used as a command line utility, it takes a few options and as argument the list of triplets of the targets.  You can find more information about the syntax of the script with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"julia build_tarballs.jl --help","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Instead of using the wizard, you can adapt for a new library a build_tarballs.jl script originally written for another library.  Then, you can build the tarballs with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"julia --color=yes build_tarballs.jl --debug --verbose","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"The --debug option will drop you into the BinaryBuilder interactive shell if an error occurs.  If the build fails, after finding out the steps needed to fix the build you have to manually update the script in build_tarballs.jl.  You should run again the above command to make sure that everything is actually working.","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Since build_tarballs.jl takes as argument the comma-separated list of targets for which to build the tarballs, you can select only a few of them.  For example, with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"julia --color=yes build_tarballs.jl --debug --verbose aarch64-linux-musl,arm-linux-musleabihf","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"you'll run the build script only for the aarch64-linux-musl and arm-linux-musleabihf targets.","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"If you decide to use this workflow, however, you will need to manually open pull requests for Yggdrasil.","category":"page"},{"location":"FAQ/#Can-I-open-a-shell-in-a-particular-build-environment-for-doing-some-quick-tests?-1","page":"FAQ","title":"Can I open a shell in a particular build environment for doing some quick tests?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Yes!  You can use BinaryBuilder.runshell(platform) to quickly start a shell in the current directory, without having to set up a working build_tarballs.jl script.  For example,","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"julia -e 'using BinaryBuilder; BinaryBuilder.runshell(Windows(:i686))'","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"will open a shell in a Windows 32-bit build environment, without any source loaded.  The current working directory of your system will be mounted on ${WORKSPACE} within this BinaryBuilder environment.","category":"page"},{"location":"FAQ/#Can-I-publish-a-JLL-package-locally-without-going-through-Yggdrasil?-1","page":"FAQ","title":"Can I publish a JLL package locally without going through Yggdrasil?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"You can always build a JLL package on your machine with the --deploy flag to the build_tarballs.jl script.  Read the help (--help) for more information.","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"A common use case is that you want to build a JLL package for, say, Libfoo, that will be used as dependency to build Quxlib, and you want to make sure that building both Libfoo and Quxlib will work before submitting all the pull requests to Yggdrasil.  You can prepare the build_tarballs.jl script for Libfoo and then build and deploy it with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"julia --color=yes build_tarballs.jl --debug --verbose --deploy=\"MY_USERNAME/Libfoo_jll.jl\"","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"replacing MY_USERNAME with your GitHub username: this will build the tarballs for all the platforms requested and upload them to a release of the MY_USERNAME/Libfoo_jll.jl, where the JLL package will also be created.  As explained above, you can pass argument the list of triplets of the platforms for you which you want to build the tarballs, in case you want to compile only some of them.  In the Julia REPL, you can install this package as any unregistered package with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"]add https://github.com/MY_USERNAME/Libfoo_jll.jl.git","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"or develop it with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"]dev https://github.com/MY_USERNAME/Libfoo_jll.jl.git","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Since this package is unregistered, you have to use the full PackageSpec specification to add it as dependency of the local builder for Quxlib:","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"    Dependency(PackageSpec(; name = \"Libfoo_jll\",  uuid = \"...\", url = \"https://github.com/MY_USERNAME/Libfoo_jll.jl.git\"))","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"You can of course in turn build and deply this package with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"julia --color=yes build_tarballs.jl --debug --verbose --deploy=\"MY_USERNAME/Quxlib_jll.jl\"","category":"page"},{"location":"FAQ/#Can-I-install-packages-in-the-build-environment?-1","page":"FAQ","title":"Can I install packages in the build environment?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Yes, but it's unlikely that you'll need to.  The build environment is based on Alpine Linux (triplet: x86_64-linux-musl) so you can use apk to install packages in it.  However, if you need runtime libraries or programs for the target system these packages won't help you.  The package manager is useful only to install utilities, tools or libraries that are needed exclusively at compile time on the build system.","category":"page"},{"location":"FAQ/#What-are-those-numbers-in-the-list-of-sources?-How-do-I-get-them?-1","page":"FAQ","title":"What are those numbers in the list of sources?  How do I get them?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"The list of sources is a vector of BinaryBuilder.AbstractSources.  What the hash is depends on what the source is:","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"For a FileSource or an ArchiveSource, the hash is a 64-character SHA256 checksum.  If you have a copy of that file, you can compute the hash in Julia with\nusing SHA\nopen(path_to_the_file, \"r\") do f\n     bytes2hex(sha256(f))\nend\nwhere path_to_the_file is a string with the path to the file.  Alternatively, you can use the command line utilities curl and shasum to compute the hash of a remote file:\n$ curl -L http://example.org/file.tar.gz | shasum -a 256\nreplacing http://example.org/file.tar.gz with the actual URL of the file you want to download.\nFor a GitSource, the hash is the 40-character SHA1 hash of the revision you want to checkout.  For reproducibility you must indicate a specific revision, and not a branch or tag name, which are moving targets.","category":"page"},{"location":"jll/#JLL-packages-1","page":"JLL packages","title":"JLL packages","text":"","category":"section"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"BinaryBuilder.jl is designed to produce tarballs that can be used in any environment, but so far their main use has been to provide pre-built libraries and executables to be readily used in Julia packages.  This is accomplished by JLL packages (a pun on \"Dynamic-Link Library\", with the J standing for Julia). They can be installed like any other Julia packages with the Julia package manager in the REPL with","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"]add NAME_jll","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"and then loaded with","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"using NAME_jll","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"However, most users will not ever need to do these steps on their own, JLL packages are usually only used as dependencies of packages wrapping binary libraries or executables.","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"Most JLL packages live under the JuliaBinaryWrappers organization on GitHub, and the builders to generate them are maintaned in Yggdrasil, the community build tree.  BinaryBuilder.jl allows anyone to create their own JLL package and publish them to a GitHub repository of their choice without using Yggdrasil, see the Frequently Asked Questions.","category":"page"},{"location":"jll/#Anatomy-of-a-JLL-package-1","page":"JLL packages","title":"Anatomy of a JLL package","text":"","category":"section"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"A somewhat popular misconception is that JLL packages are \"special\".  Instead, they are simple Julia packages with a common structure, as they are generated automatically.  This is the typical tree of a JLL package, called in this example NAME_jll.jl:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"NAME_jll\n├── Artifacts.toml\n├── LICENSE\n├── Project.toml\n├── README.md\n└── src/\n    ├── NAME_jll.jl\n    └── wrappers/\n        ├── aarch64-linux-gnu.jl\n        ├── aarch64-linux-musl.jl\n        ├── armv7l-linux-gnueabihf.jl\n        ├── armv7l-linux-musleabihf.jl\n        ├── i686-linux-gnu.jl\n        ├── i686-linux-musl.jl\n        ├── i686-w64-mingw32.jl\n        ├── powerpc64le-linux-gnu.jl\n        ├── x86_64-apple-darwin14.jl\n        ├── x86_64-linux-gnu.jl\n        ├── x86_64-linux-musl.jl\n        ├── x86_64-unknown-freebsd11.1.jl\n        └── x86_64-w64-mingw32.jl","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"These are the main ingredients of a JLL package:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"LICENSE, a file stating the license of the JLL package.  Note that this may differ from the license of the library it wraps, which is instead shipped inside the tarballs;\na README.md file providing some information about the content of the wrapper, like the list of \"products\" provided by the package;\nthe Artifacts.toml file contains the information about all the available tarballs for the given package.  The tarballs are uploaded to GitHub releases;\nthe Project.toml file describes the packages dependencies and their compatibilities;\nthe main entry point of the package is the file called src/NAME_jll.jl. This is what is executed when you issue the command\nusing NAME_jll\nThis file reads the list of tarballs available in Artifacts.toml and choose the platform matching the current platform.  Some JLL packages are not built for all supported platforms.  If the current platform is one of those platform not supported by the JLL package, this is the end of the package.  Instead, if the current platform is supported, the corresponding wrapper in the src/wrappers/ directory will be included;\nthe wrappers/ directory contains a file for each of the supported platforms.  They are actually mostly identical, with some small differences due to platfomr-specific details.  The wrappers are analyzed in more details in the following section.","category":"page"},{"location":"jll/#The-wrappers-1","page":"JLL packages","title":"The wrappers","text":"","category":"section"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"The files in the src/wrappers/ directory are very thin automatically-generated wrappers around the binary package provided by the JLL package.  They load all the JLL packages that are dependencies of the current JLL package and export the names of the products listed in the build_tarballs.jl script that produced the current JLL package.  Among others, they also define the following unexported variables:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"artifact_dir: the absolute path to where the artifact for the current platform has been installed;\nPATH: the value of the PATH environment variable needed to run executables in the current JLL package, if any;\nPATH_list: the list of directories in PATH as a vector of Strings;\nLIBPATH: the value of the environment variable that holds the list of directories in which to search shared libraries.  This has the correct value for the libraries provided by the current JLL package;\nLIBPATH_list: the list of directories in LIBPATH as a vector of Strings;\nLIBPATH_env: the name of the environment variable of the search paths of the shared libraries for the current platform.  This is equal to LD_LIBRARY_PATH on Linux and FreeBSD, DYLD_FALLBACK_LIBRARY_PATH on macOS, and PATH on Windows;","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"The wrapper files for each platform also define the __init__() function of the JLL package, the code that is executed every time the package is loaded.  The __init__() function will populate most of the variables mentioned above and automatically open the shared libraries, if any, listed in the products of the build_tarballs.jl script that generated the JLL package.","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"The rest of the code in the wrappers is specific to each of the products of the JLL package and detailed below.  If you want to see a concrete example of a package providing all the main three products, have a look at Fontconfig_jll.jl.","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"In what follows, we will use as an example a builder that has these products:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"products = [\n    FileProduct(\"src/data.txt\", :data_txt),\n    LibraryProduct(\"libdataproc\", :libdataproc),\n    ExecutableProduct(\"mungify\", :mungify_exe),\n]","category":"page"},{"location":"jll/#LibraryProduct-1","page":"JLL packages","title":"LibraryProduct","text":"","category":"section"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"A LibraryProduct is a shared library that can be ccalled from Julia.  Assuming that the product is called libdataproc, the wrapper defines the following variables:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"libdataproc: this is the exported const variable that should be used in ccall:\nnum_chars = ccall((:count_characters, libdataproc), Cint,\n                  (Cstring, Cint), data_lines[1], length(data_lines[1]))\nRoughly speaking, the value of this variable is the basename of the shared library, not its full absolute path;\nlibdataproc_splitpath: the path of the shared library, relative to artifact_dir, as returned by splitpath;\nlibdataproc_path: the full absolute path of the shared library.  Note that this is not const, thus it can't be used in ccall;\nlibdataproc_handle: the address in memory of the shared library after it has been loaded at initialization time.","category":"page"},{"location":"jll/#ExecutableProduct-1","page":"JLL packages","title":"ExecutableProduct","text":"","category":"section"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"An ExecutableProduct is a binary executable that can be run on the current platform.  If, for example, the ExecutableProduct has been called mungify_exe, the wrapper defines an exported function named mungify_exe that should run by the user in the following way:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"mungify_exe() do exe\n    run(`$exe $arguments`)\nend","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"Note that in this example exe can be replaced with any name of your choice: with the do-block syntax you are defining the name of the variable that will be used to actually call the binary with run.","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"A common point of confusion about ExecutableProducts in JLL packages is why this function is needed: while in principle you could directly run the executable directly by using its absolute path in run, this wrapper function ensures that the executable will find all shared libraries it needs while running.","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"In addition to the function called mungify_exe, for this product there will be the following unexported variables:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"mungify_exe_splitpath: the path of the executable, relative to artifact_dir, as returned by splitpath;\nmungify_exe_path: the full absolute path of the executable;","category":"page"},{"location":"jll/#FileProduct-1","page":"JLL packages","title":"FileProduct","text":"","category":"section"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"A FileProduct is a simple file with no special treatment.  If, for example, the FileProduct has been called data_txt, the only variables defined for it are:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"data_txt: this exported variable has the absolute path to the mentioned file:\ndata_lines = open(data_txt, \"r\") do io\n    readlines(io)\nend\ndata_txt_path: this unexported variable is actually equal to data_txt, but is kept for consistency with all other product types.","category":"page"},{"location":"reference/#API-reference-1","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"reference/#Types-1","page":"Reference","title":"Types","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [BinaryBuilder]\nOrder = [:type]","category":"page"},{"location":"reference/#Functions-1","page":"Reference","title":"Functions","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [BinaryBuilder]\nOrder = [:function]","category":"page"},{"location":"reference/#BinaryBuilder.autobuild-Tuple{AbstractString,AbstractString,VersionNumber,Array{#s626,1} where #s626<:BinaryBuilderBase.AbstractSource,AbstractString,Array{T,1} where T,Array{#s625,1} where #s625<:Product,Array{#s624,1} where #s624<:BinaryBuilderBase.AbstractDependency}","page":"Reference","title":"BinaryBuilder.autobuild","text":"autobuild(dir::AbstractString, src_name::AbstractString,\n          src_version::VersionNumber, sources::Vector,\n          script::AbstractString, platforms::Vector,\n          products::Vector, dependencies::Vector;\n          verbose = false, debug = false,\n          skip_audit = false, ignore_audit_errors = true,\n          autofix = true, code_dir = nothing,\n          meta_json_file = nothing, require_license = true, kwargs...)\n\nRuns the boiler plate code to download, build, and package a source package for a list of platforms.  This method takes a veritable truckload of arguments, here are the relevant actors, broken down in brief:\n\ndir: the root of the build; products will be placed within dir/products,  and mountpoints will be placed within dir/build/.\nsrc_name: the name of the source package being built and will set the name  of the built tarballs.\nsrc_version: the version of the source package.\nplatforms: a list of platforms to build for.\nsources: a vector of all sources to download and unpack before building begins, as AbstractSources.\nscript: a string representing a shell script to run as the build.\nproducts: the list of Products which shall be built.\ndependencies: a vector of JLL dependency packages as AbstractDependency that should be installed before building begins.\nverbose: Enable verbose mode.  What did you expect?\ndebug: cause a failed build to drop into an interactive shell so that  the build can be inspected easily.\nskip_audit: disable the typical audit that occurs at the end of a build.\nignore_audit_errors: do not kill a build even if a problem is found.\nautofix: give BinaryBuilder permission to automatically fix issues it  finds during audit passes.  Highly recommended.\ncode_dir: sets where autogenerated JLL packages will be put.\nrequire_license enables a special audit pass that requires licenses to be  installed by all packages.\nlazy_artifacts sets whether the artifacts should be lazy.\nmeta_json_stream: If this is set to an IOStream, do not actually build, just  output a JSON representation of all the metadata about this build to the stream.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.build_tarballs-NTuple{8,Any}","page":"Reference","title":"BinaryBuilder.build_tarballs","text":"build_tarballs(ARGS, src_name, src_version, sources, script, platforms,\n               products, dependencies; kwargs...)\n\nThis should be the top-level function called from a build_tarballs.jl file. It takes in the information baked into a build_tarballs.jl file such as the sources to download, the products to build, etc... and will automatically download, build and package the tarballs, generating a build.jl file when appropriate.  Note that ARGS should be the top-level Julia ARGS command- line arguments object.  This function does some rudimentary parsing of the ARGS, call it with --help in the ARGS to see what it can do.\n\nThe kwargs are passed on to autobuild, see there for a list of supported ones. In addition, the keyword argument init_block may be set to a string containing Julia code; if present, this code will be inserted into the initialization path of the generated JLL package. This can for example be used to invoke an initialization API of a shared library.\n\nnote: Note\nThe init_block keyword argument is experimental and may be removed in a future version of this package. Please use it sparingly.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.get_compilers_versions-Tuple{}","page":"Reference","title":"BinaryBuilder.get_compilers_versions","text":"get_compilers_versions(; compilers = [:c])\n\nReturn the script string that is used to print the versions of the given compilers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.versioninfo-Tuple{}","page":"Reference","title":"BinaryBuilder.versioninfo","text":"versioninfo()\n\nHelper function to print out some debugging information\n\n\n\n\n\n","category":"method"},{"location":"troubleshooting/#Build-Troubleshooting-1","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"This page collects some known build errors and trick how to fix them.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"If you have additional tips, please submit a PR with suggestions.","category":"page"},{"location":"troubleshooting/#All-platforms-1","page":"Build Troubleshooting","title":"All platforms","text":"","category":"section"},{"location":"troubleshooting/#Header-files-of-the-dependencies-can't-be-found-1","page":"Build Troubleshooting","title":"Header files of the dependencies can't be found","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Sometimes the build system can't find the header files of the dependencies, even if they're properly installed.  When this happens, you have to inform the C/C++ preprocessor where the files are.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"For example, if the project uses Autotools you can set the CPPFLAGS environment variable:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"export CPPFLAGS=\"-I${prefix}/include\"\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs}\nmake install","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"See for example Cairo build script.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"If instead the project uses CMake you'll need to use a different environment variable, since CMake ignores CPPFLAGS.  If the compiler that can't find the header file is the C one, you need to add the path to the CFLAGS variable (e.g., CFLAGS=\"-I${prefix}/include\"), in case it's the C++ one you have to set the CXXFLAGS variable (e.g., CXXFLAGS=\"-I${prefix}/include\").","category":"page"},{"location":"troubleshooting/#Libraries-of-the-dependencies-can't-be-found-1","page":"Build Troubleshooting","title":"Libraries of the dependencies can't be found","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Like in the section above, it may happen that the build system fails to find the libraries of the dependencies, even when they're installed to the right place.  In these case, you have to inform the linker where the libraries are by setting the LDFLAGS environment variable:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"export LDFLAGS=\"-L${libdir}\"\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs}\nmake install","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"See for example libwebp build script (in this case this was needed only when building for FreeBSD).","category":"page"},{"location":"troubleshooting/#Old-Autoconf-helper-scripts-1","page":"Build Troubleshooting","title":"Old Autoconf helper scripts","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Packages using Autoconf come with some helper scripts – like config.sub and config.guess – that the upstream developers need to keep up-to-date in order to get the latest improvements.  Some packages ship very old copies of these scripts, that for example don't know about the Musl C library.  In that case, after running ./configure you may get an error like","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"checking build system type... Invalid configuration `x86_64-linux-musl': system `musl' not recognized\nconfigure: error: /bin/sh ./config.sub x86_64-linux-musl failed","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The BinaryBuilder environment provides the utility update_configure_scripts to automatically update these scripts, call it before ./configure:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"update_configure_scripts\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nproc}\nmake install","category":"page"},{"location":"troubleshooting/#Building-with-an-old-GCC-version-a-library-that-has-dependencies-built-with-newer-GCC-versions-1","page":"Build Troubleshooting","title":"Building with an old GCC version a library that has dependencies built with newer GCC versions","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The keyword argument preferred_gcc_version to the build_tarballs function allows you to select a newer compiler to build a library, if needed.  Pure C libraries have good compatibility so that a library built with a newer compiler should be able to run on a system using an older GCC version without problems.  However, keep in mind that each GCC version in BinaryBuilder.jl comes bundled with a specific version of binutils  – which provides the ld linker – see this table.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"ld is quite picky and a given version of this tool doesn't like to link a library linked with a newer version: this means that if you build a library with, say, GCC v6, you'll need to build all libraries depending on it with GCC >= v6.  If you fail to do so, you'll get a cryptic error like this:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"/opt/x86_64-linux-gnu/bin/../lib/gcc/x86_64-linux-gnu/4.8.5/../../../../x86_64-linux-gnu/bin/ld: /workspace/destdir/lib/libvpx.a(vp8_cx_iface.c.o): unrecognized relocation (0x2a) in section `.text'\n/opt/x86_64-linux-gnu/bin/../lib/gcc/x86_64-linux-gnu/4.8.5/../../../../x86_64-linux-gnu/bin/ld: final link failed: Bad value","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The solution is to build the downstream libraries with at least the maximum of the GCC versions used by the dependencies:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"build_tarballs(ARGS, name, version, sources, script, platforms, products, dependencies; preferred_gcc_version=v\"8\")","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"For instance, FFMPEG has to be built with GCC v8 because LibVPX requires GCC v8.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Generally speaking, we try to build with the as old as possible version of GCC (v4.8.5 being the oldest one currently available), for maximum compatibility.","category":"page"},{"location":"troubleshooting/#Running-foreign-executables-1","page":"Build Troubleshooting","title":"Running foreign executables","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The build environment provided by BinaryBuilder is a x86_64-linux-musl, and it can run executables for the following platforms: x86_64-linux-musl, x86_64-linux-gnu, i686-linux-gnu.  For all other platforms, if the build system tries to run a foreign executable you'll get an error, usually something like","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"./foreign.exe: line 1: ELF��\n                       @@xG@8@@@@@@���@�@@����A�A����A�A���@�@: not found\n./foreign.exe: line 1: syntax error: unexpected end of file (expecting \")\")","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"This is one of worst cases when cross-compiling, and there isn't a simple solution.  You have to look into the build process to see if running the executable can be skipped (see for example the patch to not run dot in #351), or replaced by something else.  If the executable is a compile-time only utility, try to build it with the native compiler (see for example the patch to build a native mkdefs in #351)","category":"page"},{"location":"troubleshooting/#PowerPC-Linux-1","page":"Build Troubleshooting","title":"PowerPC Linux","text":"","category":"section"},{"location":"troubleshooting/#Shared-library-not-built-1","page":"Build Troubleshooting","title":"Shared library not built","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Sometimes the shared library for powerpc64le-linux-gnu is not built after a successful compilation, and audit fails because only the static library has been compiled.  If the build uses Autotools, this most likely happens because the configure script was generated with a very old version of Autotools, which didn't know how to build shared libraries for this system.  The trick here is to regenerate the configure script with autoreconf:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"autoreconf -vi\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nproc}\nmake install","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"See for example the builder for Giflib.  If you need to regenerate configure, you'll probably need to run update_configure_scripts to make other platforms work as well.","category":"page"},{"location":"troubleshooting/#FreeBSD-1","page":"Build Troubleshooting","title":"FreeBSD","text":"","category":"section"},{"location":"troubleshooting/#undefined-reference-to-backtrace_symbols'-1","page":"Build Troubleshooting","title":"undefined reference to `backtrace_symbols'","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"If compilation fails because of the following errors","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"undefined reference to `backtrace_symbols'\nundefined reference to `backtrace'","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"then you need to link to execinfo:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"if [[ \"${target}\" == *-freebsd* ]]; then\n    export LDFLAGS=\"-lexecinfo\"\nfi\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs}\nmake install","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"See for example #354 and #982.","category":"page"},{"location":"troubleshooting/#Windows-1","page":"Build Troubleshooting","title":"Windows","text":"","category":"section"},{"location":"troubleshooting/#Libtool-refuses-to-build-shared-library-because-of-undefined-symbols-1","page":"Build Troubleshooting","title":"Libtool refuses to build shared library because of undefined symbols","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"When building for Windows, sometimes libtool refuses to build the shared library because of undefined symbols.  When this happens, compilation is successful but BinaryBuilder's audit can't find the expected LibraryProducts.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"In the log of compilation you can usually find messages like","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"libtool: warning: undefined symbols not allowed in i686-w64-mingw32 shared libraries; building static only","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"or","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"libtool:   error: can't build i686-w64-mingw32 shared library unless -no-undefined is specified","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"In these cases you have to pass the -no-undefined option to the linker, as explicitly suggested by the second message.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"A proper fix requires to add the -no-undefined flag to the LDFLAGS of the corresponding libtool archive in the Makefile.am file.  For example, this is done in CALCEPH, ERFA, and libsharp2.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"A quick and dirty alternative to patching the Makefile.am file is to pass LDFLAGS=-no-undefined only to make:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"FLAGS=()\nif [[ \"${target}\" == *-mingw* ]]; then\n    FLAGS+=(LDFLAGS=\"-no-undefined\")\nfi\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs} \"${FLAGS[@]}\"\nmake install","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Note that setting LDFLAGS=-no-undefined before ./configure would make this fail because it would run a command like cc -no-undefined conftest.c, which upsets the compiler).  See for example #170, #354.","category":"page"},{"location":"#BinaryBuilder.jl-1","page":"Home","title":"BinaryBuilder.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The purpose of the BinaryBuilder.jl Julia package is to provide a system for compiling 3rd-party binary dependencies that should work anywhere the official Julia distribution does.  In particular, using this package you will be able to compile your large pre-existing codebases of C, C++, Fortran, Rust, Go, etc... software into binaries that can be downloaded and loaded/run on a very wide range of machines.  As it is difficult (and often expensive) to natively compile software packages across the growing number of platforms that this package will need to support, we focus on providing a set of Linux-hosted cross-compilers.  This package will therefore set up an environment to perform cross-compilation for all of the major platforms, and will do its best to make the compilation process as painless as possible.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that at this time, BinaryBuilder itself runs on Linux x86_64 and macOS x86_64 systems only, with Windows support under active development.  On macOS and Windows, you must have docker installed as the backing virtualization engine.  Note that Docker Desktop is the recommended version; if you have Docker Machine installed it may not work correctly or may need additional configuration.","category":"page"},{"location":"#Project-flow-1","page":"Home","title":"Project flow","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Suppose that you have a Julia package Foo.jl which wants to use a compiled libfoo shared library.  As your first step in writing Foo.jl, you may compile libfoo locally on your own machine with your system compiler, then using Libdl.dlopen() to open the library, and ccall() to call into the exported functions.  Once you have written your C bindings in Julia, you will naturally desire to share the fruits of your labor with the rest of the world, and this is where BinaryBuilder can help you.  Not only will BinaryBuilder aid you in constructing compiled versions of all your dependencies, but it will also build a wrapper Julia package (referred to as a JLL package) to aid in installation, versioning, and build product localization.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The first step in the BinaryBuilder journey is to create a build recipe, usually named build_tarballs.jl.  The Julia community curates a tree of build recipes, Yggdrasil, that already contains many examples of how to write a build_tarballs.jl file.  These files contain information such as the name, version and source locations for a particular build, as well as the actual steps (in the form of a bash script) and the products that should be generated by the build.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The result of a successful build is an autogenerated JLL package, typically uploaded to the JuliaBinaryWrappers github organization.  Binaries for each version of every build are uploaded to the GitHub releases page of the relevant JLL package.  Finally, a registration request is opened against the General Julia registry, so that packages such as the aforementioned Foo.jl can simply pkg> add libfoo_jll to download the binary artifacts as well as the autogenerated Julia wrapper code.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To generate a build_tarballs.jl file (explained in greater detail below), one can clone Yggdrasil, copy an existing build recipe, modify it, and submit a new PR, or use the BinaryBuilder Wizard to do all of that automatically.  See also the FAQ, build tips, and tricksy gotchas for help with common problems.","category":"page"},{"location":"#Build-scripts-1","page":"Home","title":"Build scripts","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A BinaryBuilder.jl build script (what is often referred to as a build_tarballs.jl file) looks something like this:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using BinaryBuilder\n\nname = \"libfoo\"\nversion = v\"1.0.1\"\nsources = [\n    ArchiveSource(\"<url to source tarball>\", \"sha256 hash\"),\n]\n\nscript = raw\"\"\"\ncd ${WORKSPACE}/srcdir/libfoo-*\nmake -j${nproc}\nmake install\n\"\"\"\n\nplatforms = supported_platforms()\n\nproducts = [\n    LibraryProduct(\"libfoo\", :libfoo),\n    ExecutableProduct(\"fooifier\", :fooifier),\n]\n\ndependencies = [\n    Dependency(\"Zlib_jll\"),\n]\n\nbuild_tarballs(ARGS, name, version, sources, script, platforms, products, dependencies)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This bare-bones snippet first identifies the sources to download and compile (there can be multiple sources listed here), then lists the bash commands to actually build this particular project.  Next, the products are defined, which are the files that must exist at the end of the build, and which are wrapped in the eventual JLL package.  Finally, we pass this information off to build_tarballs(), which takes it all in and runs the builds, placing output tarballs into the ./products directory.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The bash commands contained within script will be executed for each platform that is passed in, so if there are platform differences that need to be addressed in the build script, using if statements and the $target environment variable can be a powerful tool.  See the OpenBLASBuilder build script for an example showcasing this.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"While constructing your own build script is certainly possible, BinaryBuilder.jl supports a more interactive method for building the binary dependencies and capturing the commands used to build it into a build_tarballs.jl file; the Wizard interface.","category":"page"},{"location":"#Wizard-interface-1","page":"Home","title":"Wizard interface","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BinaryBuilder.jl contains a wizard interface that will walk you through constructing a build_tarballs.jl file.  To launch it, run BinaryBuilder.run_wizard(), and follow the instructions on-screen.","category":"page"},{"location":"#How-does-this-all-work?-1","page":"Home","title":"How does this all work?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BinaryBuilder.jl wraps a root filesystem that has been carefully constructed so as to provide the set of cross-compilers needed to support the wide array of platforms that Julia runs on.  This RootFS is then used as the chroot jail for a sandboxed process which runs within the RootFS as if that were the whole world.  The workspace containing input source code and (eventually) output binaries is mounted within the RootFS and environment variables are setup such that the appropriate compilers for a particular target platform are used by build tools.","category":"page"},{"location":"tricksy_gotchas/#Tricksy-Gotchas-1","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"","category":"section"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"There are a plethora of gotchas when it comes to binary compilation and distribution that must be appropriately addressed, or the binaries will only work on certain machines and not others.  Here is an incomplete list of things that BinaryBuilder.jl takes care of for you:","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Uniform compiler interface","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"No need to worry about invoking compilers through weird names; just run gcc within the proper environment and you'll get the appropriate cross-compiler.  Triplet-prefixed names (such as x86_64-linux-gnu-gcc) are, of course, also available, and the same version of gcc, g++ and gfortran is used across all platforms.","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"glibc versioning","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"On Linux platforms that use glibc as the C runtime library (at the time of writing, this is the great majority of most desktop and server distros), it is necessary to compile code against a version of glibc that is older than any glibc version it will be run on.  E.g. if your code is compiled against glibc v2.5, it will run on glibc v2.6, but it will not run on glibc v2.4.  Therefore, to maximize compatibility, all code should be compiled against as old a version of glibc as possible.","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"gfortran versioning","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"When compiling FORTRAN code, the gfortran compiler has broken ABI compatibility in the 6.X -> 7.X transition, and the 7.X -> 8.X transition.  This means that code built with gfortran 6.X cannot be linked against code built with gfortran 7.X.  We therefore compile all gfortran code against multiple different gfortran versions, then at runtime decide which to download based upon the currently running process' existing linkage.","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"cxx11 string ABI","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"When switching from the cxx03 standard to cxx11 in GCC 5, the internal layout of std::string objects changed.  This causes incompatibility between C++ code passing strings back and forth across the public interface if they are not built with the same C++ string ABI.  We therefore detect when std::string objects are being passed around, and warn that you need to build two different versions, one with cxx03-style strings (doable by setting -D_GLIBCXX_USE_CXX11_ABI=0 for newer GCC versions) and one with cxx11-style strings.","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Library Dependencies","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"A large source of problems in binary distribution is improper library linkage.  When building a binary object that depends upon another binary object, some operating systems (such as macOS) bake the absolute path to the dependee library into the dependent, whereas others rely on the library being present within a default search path.  BinaryBuilder.jl takes care of this by automatically discovering these errors and fixing them by using the RPATH/RUNPATH semantics of whichever platform it is targeting.  Note that this is technically a build system error, and although we will fix it automatically, it will raise a nice yellow warning during build prefix audit time.","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Embedded absolute paths","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Similar to library dependencies, plain files (and even symlinks) can have the absolute location of files embedded within them.  BinaryBuilder.jl will automatically transform symlinks to files within the build prefix to be the equivalent relative path, and will alert you if any files within the prefix contain absolute paths to the build prefix within them.  While the latter cannot be automatically fixed, it may help in tracking down problems with the software later on.","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Instruction Set Differences","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"When compiling for architectures that have evolved over time (such as x86_64), it is important to target the correct instruction set, otherwise a binary may contain instructions that will run on the computer it was compiled on, but will fail rather ungracefully when run on a machine that does not have as new a processor.  BinaryBuilder.jl will automatically disassemble every built binary object and inspect the instructions used, warning the user if a binary is found that does not conform to the agreed-upon minimum instruction set architecture.  It will also notice if the binary contains a cpuid instruction, which is a good sign that the binary is aware of this issue and will internally switch itself to use only available instructions.","category":"page"}]
}
